---
date: 2015-2-27 22:50:12+00:00
layout: post
title: Linux下的并发编程
thread: 16
categories: 读书笔记
tags: CS-APP
---
##关于并发
在这里就不讲解什么是并发之类的概念了，在看这篇文章的时候我相信你对并发已经有了一定了了解，这里我们简单的讨论Linux中几种实现并发的常用方式并对其进行比较分析。

- 进程。每个逻辑控制流都是一个单独的进程，由内核来维护调度
- IO多路复用。在同一个进程的上下文中显示地调度他们自己的逻辑流，在一个进程中可监控多个IO描述符。
- 线程。线程是运行在一个单独的上下文中的逻辑流，由内核进行调度。

从以上的三种并发方式可以看出，我们对计算机的理解是不断的进化的，由重量级的进程进化到轻量级的线程。现在人们并发编程的时候第一个选择肯定是线程而不是进程。

##基于进程的并发
一个最简单的进程并发模型可以这样的，一个服务响应多个客户端来的请求，这样是我们常见的C/S模型。当服务端每次收到一个客户端的连接时创建一个新的进程来进行处理。这个大概也是一种最原始的并发方式。下面是一个简单的的图示模型。

![1]
下面是对这个模型的一个简单实现，客户机-1向服务器发送[1-10]，进程-1输出客户机-1发送的数据，客户机-2向服务器发送[11-20],进程-2输出客户机-2的数据。

server代码参考：[github_server]

client-1代码参照:[github_client1]

client-2代码参照:[github_client2]

输出如下:

![2]

从单进程处理业务到多进程方式的并发处理多个业务，肯定给我们的程序设计带来了很大的创新。同时也引入了很多的问题：

- 每个系统可以创建的进程是有限的，在这种网络编程中如果每个客户机我们都创建一个进程的话可能很快就会达到系统创建进程的个数的极限值
- 由于操作系统从一个进程上下文切换到另外一个进程的上下文需要很大的系统系统开销，多个进程的频繁切换也就使系统的处理能力下降
- 由于每个进程相对都是独立的，这就导致进程之前的通信不能再像一个进程中那么方便，这就引入了IPC的概念（之后会专门有一篇文章来总结各种IPC的方式）


##基于I/O多路复用的并发
I/O多路复用一改以往主动阻塞在accept函数处监听新的客户端的连接的方式，使用select函数来监听需要监听的list，只有在一个或者多个I/O事件发生后，程序才会向下执行，对发生变化的文件描述符进行操作处理。
如下一个简单的模型:

server代码参考：[github_server_select]

client-1代码参照:[github_client1]

client-2代码参照:[github_client2]

输出如下:

![3]


由于I/O多路复用是对现有的多进程编程的一种改进，所有他就有了很多的优点。

- 由于我们是监听一系列的的文件描述符，所有对一些特殊的文件可以进行特殊的处理，程序员对程序的行为控制更方便了。
- 用于I/O多路复用是在单进程中完成的，所有的代码都在同一个地址空间中，每个io间的交互就变的更加的容易。

缺点嘛就很明显了，在select模型的代码中你可以看到很多的大括号。这就大大的增加了代码的复杂性，可读性也大大的降低了。

##基于线程的并发
编程方式真的是不断进化的，从多进程到IO复用，再到下面描述的多线程，可以看到明显的改进。基于线程的并发编程方式就是上述两种的混合。

线程----你可以理解为可以独立工作的子函数，他是由内核自动调度，由于多个线程是运行在同一个进程的地址空间中，因此共享这个进程地址空间中的所有内容，包括他的代码，数据，堆栈，共享库以及打开的文件描述符。

如下是一个简单的线程示例代码：
```
```
  
	1 #include <stdio.h>
  	2 #include <string.h>
  	3 #include <stdlib.h>
  	4 #include <pthread.h>
  	5
  	6 void *thread(void *vargp)
  	7 {
  	8    printf("Hello world\n");
  	9    return NULL;
 	10 }
 	11
 	12 int main()
 	13 {
 	14    pthread_t tid;
 	15    pthread_create(&tid, NULL, thread, NULL);
 	16    pthread_join(tid, NULL);
 	17    exit(0);
 	18 }

线程就是将本地的函数封装在一个线程实例中，pthread_create创建一个线程并在其中运行thread函数。
线程版的Socket编程模型：

server代码参考：[github_server_thread]

client-1代码参照:[github_client1]

client-2代码参照:[github_client2]

输出如下:

![4]


-END
[1]:../album/ch13/process_concurrency.png ""
[2]:../album/ch13/process_concurrency_output.png "process concurrency output" 
[3]:../album/ch13/select_concurrency_output.png "select concurrency output"
[4]:../album/ch13/thread_concurrency_output.png "thread concurrency output"
[github_server]:https://github.com/lzh2nix/CS-APP/blob/master/ch13/server.c "server code"
[github_client1]:https://github.com/lzh2nix/CS-APP/blob/master/ch13/client1.c

[github_client2]:https://github.com/lzh2nix/CS-APP/blob/master/ch13/client2.c

[github_server_select]:https://github.com/lzh2nix/CS-APP/blob/master/ch13/server_select.c "server_select"
[github_server_thread]:https://github.com/lzh2nix/CS-APP/blob/master/ch13/server_thread.c "server_thread"
