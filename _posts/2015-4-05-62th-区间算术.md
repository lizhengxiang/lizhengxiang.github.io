---
date: 2015-4-05 14:40:12+00:00
layout: post
title: SICP 62th-区间算术
thread: 19
categories: 读书笔记
tags: SICP
---

最近一个月忙着提交SICP的练习题，就没怎么更新这里的内容了。这确实是一本很神奇的书，每一个练习题都会让你有新的认识。记得之前好几次翻开这书的时候都停留在了第一章的前几节，也许是在工作中经常用erlang的原因，感觉对函数式编程没有那么陌生了。之后这里的话会更新一些习题的解答，我觉得每一个习题后面的思想都应该记录下来。

###2.7求区间的upper\_bound和lower\_bound
这里题目主要考察的是你对序对的理解，前面的定义已经给出了定义区间的函数就是：

	(define (make-interval a b) (cons a b))

其中的a和b就是区间的upper bound 和lower bound, 使用`car` `cdr`即可求出，即:

	(define (lower-bound a) (car a))

	(define (upper-bound a) (cdr a))


###2.8计算两个区间的差值
这里主要的思想就是 a - b = a + (-b),将其带入add-interval就是：
```
```

 	(define (sub-interval x y)
 		(make-interval (- (lower-bound x) (upper-bound y))
 	                   (- (upper-bound x) (lower-bound y))))

###2.9计算区间的宽度
根据区间宽度的定义我们可以有如下的计算:

假如有区间A = [a,b], B = [c,d] 这两个区间的宽度为:

	width(A) = (b - a)/2
	width(B) = (d - c)/2

两个区间的和为:A + B = [a + c, b + d]，它的宽度为：

	width(A + B) = (b + d - a - c)/2
                = (b - a)/2 + (d - c)/2
                = width(A) + width(B)
同样的方式两个区间的差为：`A - B = [a - c, b - d]，它的宽度为：
	
	width(A - B) = (b - d - a + c)/2
                = (b - a)/2 - (d + c)/2
                = width(A) - width(B)
针对除法和乘法就不一定了，因为他们的上下界不是唯一确定了，根据区间的关系会发生变化。

###2.10 除运算的问题
主要是在除运算的时候除数不能为0，如果为0报出相应的错误即可

###2.11 乘积运算的另外一种表示
先来看下区间乘积的定义好了:
		
	[a, b] × [c, d] = [min(ac, ad, bc, bd), max(ac, ad, bc, bd)]
这里由于我们不知道ac, ad, bc, ad里面那个最大那个最小所有需要求出所有的值后比较，这里优化后只需要2次乘积运算，无非是直接可以知道ac, ad, bc, bd里面那个最大那个最小。现在又如下的坐标轴：

	-----a1-------b1------a2-----0-----b2--------a3------b3--------->

任何一个区间都是[a1, b1], [a2, b2], [a3, b3]中的一类。如果我们能够唯一的确定一个区间到底属于A1, A2, A3中的某一个也就没必要去计算出ac, ad, bc, bd的值，只需要计算其中的两个就可以了。
假如区间C1[a, b]∈A3， C2[c, d]∈A3,那么ac肯定就是最小的,bd肯定就是最大的。即
	
	C1 × C2 = [ac, bd]

区间A有3种可能，区间B有3种可能。A×B也就是9种可能。每次只要两次乘积运算。一个例外就是：
C1和C2都属于A2，那么就用多种情况了。

	C1 = [a, b], C2 = [c, d]
做四乘积运算后的结果是ac, ad, bc, bd, 这里我们唯一知道的关系是 a < b, c < d,从这里我们无法判断出,ac和bd的大小，两种情况下：

	-----a--c----------------0-b-d------------------------->
	---------------------c-a-0--------------b-------d------>
这种情况下的C1 × C2 = [min(ad, bc), max(ac, db)]

###2.12 百分数法表示区间误差
这道题不知道在考些什么,就是一个简单的对上面描述的重复。

###2.13 乘积的误差推倒
假设区间A的百分数误差是Δx,中心点是a,区间B的百分数误差是Δy,中心点是b，那么

	A = [a - aΔx, a + aΔx]
	B = [b - bΔy, b + bΔy]

这里有一个简化就是假设A和B都是属于[0, +∝]的，那么

	A × B = [(a - aΔx)(b - bΔy), (a + aΔx)(b + bΔy)]

A × B的中心点:

	center(AB)  = ((a + aΔx)(b + bΔy) + (a - aΔx)(b - bΔy))/2
			   = (ab + abΔy + abΔy + abΔxΔy + ab - abΔy - abΔx + abΔxΔy)/2
			   = ab + abΔxΔy
A × B的宽度:


	width(AB)  = ((a + aΔx)(b + bΔy) - (a - aΔx)(b - bΔy))/2
			  = (ab + abΔy + abΔy + abΔxΔy - ab + abΔy + abΔx - abΔxΔy)/2
			  = abΔy + abΔx

A × B的百分比度量值:

	percnet-tolerance(AB)  = width(AB)/center(AB)
                         = (abΔy + abΔx)/(ab + abΔxΔy)
                         = (Δx + Δy)/(1 + ΔxΔy)
这里有一个假设就是	Δy和Δx很小，从而 1+ ΔxΔy ≈ 1 即：

	 percnet-tolerance(AB) = Δx + Δy
推理完毕。

###2.14--2.16
对这三个题只能做简单的验证如下：

>1 ]=> (par2 (make-interval 1.011 1.11) (make-interval 2.00003 2.00009))

>;Value 33: (.6715410773057724 . .7138378310595515)

>1 ]=> (par1 (make-interval 1.011 1.11) (make-interval 2.00003 2.00009))

>;Value 34: (.6501517094360613 . .7373224112679052)

可以看出两次计算的结果却是不同的。主要是由于小数做各种运算值后他的精度就发生了一定的变化，从而导致了误差的变大。

-END
