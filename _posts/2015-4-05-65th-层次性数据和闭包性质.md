---
date: 2015-4-08 21:53:12+00:00
layout: post
title: SICP 65th-层次性数据和闭包性质
thread: 20
categories: 读书笔记
tags: SICP
---
一直看到别人在blog里讨论各种语言的闭包性，有讨论C语言的也有python的。看到这里后也就明白什么是闭包了。简而言之就是构成序对的一个元素也是一个序对。你可不要小瞧这句话的威力，这是构造一切数据复杂数据结构的基石，如果没有闭包性的话也就没有类C语言中的结构这一概念了。总体来说这一小节的练习也没有什么难度，就是对序列的反复练习，你唯一需要记住的就是如下的数据结构的表示。
![1]

(cons 1 (cons 2 (cons 3 (cons 4 '()))))

###练习2.17 返回非空表中的最后一个元素。
就拿上面例子中的表说，最后一个非空元素就是4，这里我们从头到尾遍历一遍如果遇到序对中的cdr为空则返回即可:
```
```

	;before '() is the last pair 
	(define (last-pair items)
		(if (null? (cdr items))
      		(car items)
      		(last-pair (cdr items)))


###练习2.18 reverse一个序表

这里主要使用前面练习中的append方法，将反转后的每个序对作用到append方法上

	(reverse (list 1 2 3 4 5)) = (append (list 5) (list 4) (list 3) (list 2) (list 1))
代码如下：
```
``` 

	(define (reverse items)
		(if (null? (cdr items))
			items
			(append (reverse (cdr items)) (cons (car items) '()))))
测试code：
>(reverse (list 1 2 3 4 5))

这里的话还有一个迭代的方法就是不断的取出第一个序对然后插到前面去。

###练习2.19自定义方式换取零钱
这个题目的话按照书上的提示即可完成,已经给了很明确的提示。
```
```

	(define (except-first-denomination items)
		(cdr items))

	(define (first-denomination items)
		(car items))

###练习2.20返回一个和第一个元素奇偶性相同的序对表
使用之前给出的带点尾部形式的define，从参数列表去得到所需要参数列表。然后**car**得到第一个元素并判断它的奇偶性，之后就是简单的遍历从其中挑出符合要求的序对组合成一个序表。
```
```

	(define (get-all-evens items)
		(define (iter result last)
			(if (null? last)
				result
				(if (even? (car last))
					(iter (append result (cons (car last) '())) (cdr last))
					(iter result (cdr last)))))
		(iter '() items))

	(define (get-all-odds items)
		(define (iter result last)
			(if (null? last)
				result
				(if (odd? (car last))
					(iter (append result (cons (car last) '())) (cdr last))
					(iter result (cdr last)))))
		(iter '() items))

	(define (same-parity . items)
		(let ((first (car items)))
			(if (even? first)
				(get-all-evens items)
				(get-all-odds items))))

测试code:
>(get-all-odds (list 1 2 3 4 5 6 7))	

>(get-all-evens (list 1 2 3 4 5 6 7))

>(same-parity 1 2 3 4 5 6 7 8 9 10)

>(same-parity 2 3 4  5 6 7 8 9 10)

上面的代码也可以进一步的优化将get-all-odds和get-all-evens合并起来，但是合并起来后里面的逻辑很烦，保持code的简单明了也是一种美。


###练习2.21 square-list的两种表示
根据之前的map定义和练习中给出的骨架直接把代码填进去就可以了。
```
```

	(define (map proc items)
		(if (null? items)
			'()
			(cons (proc (car items)) (map proc (cdr items)))))

	(define (square-list items)
		(map square items))

	(define (square-list-v2 items)
		(if (null? items)
			'()
			(cons (square (car items)) (square-list-v2 (cdr items)))))

测试code:
>(map abs (list 1 2 3 4 -1 -10 -12))

>(square-list (list 1 2 3 4 5 6 7))

>(square-list (list 1 2 3 4 5 6 7))
>
>(square-list-v2 (list 1 2 3 4 5 6 7))
>
###练习2.22 Louis的迭代版square-list的问题
这迭代版的问题很明显的，可以拿一个很短的list自己做一下展开就可以了。展开后的版本是这样的。
第一次调用后result的结果：

						(cons (square 1) '())

第二次调用后是result的结果是:
						
						(cons (square 2) (cons 1 '()))

最后返回的结果就是:(2 1),正好反向的。

针对第二个版本的square-list也是一样的，简单的一个例子展开后就可以看出来:
第一次调用后result的结果：

						(cons '() (square 1))

第二次调用后是result的结果是：
						
						(cons (cons '() (square 1)) (square 2))

最后得到的结果就是：

						((() . 1) . 4)
正确的迭代版本：
```
```

	(define (square-list items)
		(define (iter things answer)
			(if (null? things)
				answer
				(iter (cdr things) (append answer (cons (square (car things)) '())))))
		(iter items '()))
测试code:
>(square-list (list 1 2 3 4 5 6 7))

使用append将新的序对放到序对列表中的最后。

###练习2.23 自己构造一个类似python中的for-each过程
和map的过程差不多，唯一的不同的就是每次迭代处理将数据输出后丢弃。然后考虑输入为空情况。
```
```

	(define (for-each proc items)
		(define (iter things item)
			(proc item)
			(if (null? things)
				(newline)
				(iter (cdr things) (car things))))
		(if (null? items)
			(newline)
			(iter (cdr items) (car items))))
测试code:
>(for-each (lambda (x) (newline) (display x)) (list 1 2 3 4 5 6 7))
>
>(for-each (lambda (x) (newline) (display x)) '())


慢慢的发现对这里的练习也能得心应手了。加油!!!!!

-END


[1]:../album/SICP/ch2/list.png "list"
