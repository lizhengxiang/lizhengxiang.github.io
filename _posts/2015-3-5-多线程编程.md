---
date: 2015-3-07 10:50:12+00:00
layout: post
title: Linux下的多线程编程
thread: 17
categories: 读书笔记
tags: CS-APP
---
###关于多线程编程
对于多线程的基本介绍我们在前一篇文章中已经做过了，这里我们就来看看多线给我带来了那些利的同时引入了那些弊端。由于多个线程在同一个进程的地址空间中，两个线程间的数据通信就没有像进程通信那么复杂了，只要是共享变量他们就可以任意的访问。所有的东西有利就有弊的，共享方便的同时也就引入了数据保护的问题，怎样保持数据的一致性就成了一个很大的问题？
下面就来看一段代码：
```
```

	#include <stdio.h>
	#include <stdlib.h>
	#include <pthread.h>
	#define MAX 10000000

	unsigned int cnt = 0;
	void *count(void *vptr)
	{
		int i;
		for(i = 0; i< MAX; i++){
			cnt++;
		}
	}

	int main()
	{
		pthread_t tid1, tid2;
		pthread_create(&tid1,NULL,count, NULL);
		pthread_create(&tid2,NULL,count, NULL);

		pthread_join(tid1, NULL);
		pthread_join(tid2, NULL);

		if(MAX*2 != cnt)
			printf("BOOM!!!!!cnt = %d\n", cnt);
		else
			printf("OK cnt = %d\n", cnt);
		exit(0);
	}

列为看官这里的输出是什么？理想的输出应该是这样的，创建两个线程执行count函数后cnt的值应该是2*MAX = 20000000，但是你想象不到的是实际的输出是这样的:

![1]

明显的可以看出每次的值都不一样。那么究竟是什么原因造成了这种情况呢？假设count函数更新cnt变量经过一下的三个步骤:

		L:将当前cnt的值加载到寄存器中
		I:对寄存器中的cnt进行加1操作
		S:将加1后的值保存起来
OK，创建连个线程后各自的线程中进行着以上的三个操作，我们理想的情况下是这样的:

![2]

这是一个很理想的过程，线程-1先进行读-更新-写的操作，之后再让到线程-2进行执行，但是由于两个线程是独立并行运行的，你实际看到的情况可能是这样的。

![3]

现在我们做的就是按照我们预想的去执行，也就是保证每次只有一个线程对cnt进行Load,Inc，Store顺序的操作，中间不允许有其他线程对cnt进行操作。

##线程安全
可能你也看到了引入线程的同时给我们的数据保护带来了很大的麻烦？上述第一个版本的count函数就不是一个线程安全的函数，所谓线程安全函数就是，当且仅当多个并发线程反复的调用时，他会一直产生正确的结果，常见的线程不安全函数有一下几类：

- 不保护共享变量的函数。多个线程调用的时候按照顺序不同产生不同的值。
- 一个函数的计算结果依赖于另外一个函数，由于一个锁不能跨函数执行所有，无法保证被调用函数的安全性。
- 静态变量在多个线程的多个函数被修改
- 调用线程不安全函数的函数

我们要做的呢就是避免上面的几种情况的发生。
##竞争
当一个程序的正确性依赖于一个线程要在另一个线程到达Y点之前到达他的控制流中的X点时，就会发生竞争(race)，其主要原因还是我们经常会人为的假设每个线程执行的顺序(这也是我目前看到描述竞争最简洁准确的)。下面请看如下的代码：
```
```
	
  	1 #include <stdio.h>
  	2 #include <pthread.h>
  	3 #define N 20
  	4
  	5 void *thread(void *vargp)
  	6 {
  	7    int myid = *((int *)vargp);
  	8    printf("Hello Number from thread:%d\n", myid);
  	9 }
 	10
 	11 int main()
 	12 {
 	13    pthread_t tid[N];
 	14    int i=0;
 	15    for(i = 0; i < N; i++){
 	16       pthread_create(&tid[i], NULL, thread, &i);
 	17    }
 	18    for(i = 0; i< N; i++){
 	19       pthread_join(tid[i], NULL);
 	20    }
 	21    return 0;
 	22 }
列为看官，你觉得这里的输出是什么？会是

	Hello Number from thread：0
	Hello Number from thread：1
	Hello Number from thread：2
	Hello Number from thread：3
	Hello Number from thread：4
				*
				*
吗？但是实际运行的结果可能会震惊到你。实际的输出结果如下:

![4]
造成这种结果的原因有两个：

- 当创建多个线程后我们并不知道那个线程先运行
- 主线程和子线程对i的访问存在竞争，主要依赖操作系统的调度。


解决这个问题的关键就在解决主线和子线程对i的竞争，我们可以给每个线程的参数i分配一个单独的空间，保证每次子线程的读都是在主线程的写之后。更改后的输出如下:

![5]

可以看到解除了对i的竞争。每个线程都正确的的访问到了自己的i.


##死锁
这是一个忧桑而抓狂的话题。

-END
[1]:../album/ch13/badcnt_output.png "bad cnt output"

[2]:../album/ch13/normal_process_output.png "normal process output"

[3]:../album/ch13/abnormal_process_output.png "normal process output"

[4]:../album/ch13/race_output.png "race output"
[5]:../album/ch13/race_output_1.png "race output_1"
