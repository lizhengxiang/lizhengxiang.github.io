---
date: 2015-1-21 20:50:12+00:00
layout: post
title: 操作系统中的虚拟存储器管理
thread: 14
categories: 读书笔记
tags: CS-APP
---

###虚拟内存管理
现代操作系统里有两个模块的设计是很美的，一个是网络，另一个就是虚拟内存管理了。他将硬件异常，硬件地址翻译，磁盘文件管理和内核完美的结合。给每个程序一个独立的地址空间使其不容易被其他进程所破坏，给每程序一个一致的地址空间从而简化了存储器的管理。

###操作系统是怎么样管理内存的？
在没有虚拟存储管理出现之前，操作系统就是将存储器作为一个很大的数组，每次执行一条指令的时候，直接通过物理地址访问存储器中的值。出现虚拟存储管理之后，CPU首先将虚拟地址给到MMU，然后MMU完成从虚拟地址到物理地址的映射然后将值返回给CPU，详细见下图。
 
![1]
OK,有了上面的概念后可以继续向下看了，和之前章节中的存储器管理一样，虚拟存储器也有缓冲命中和不命中的情况，VM系统将虚拟存储器分为了固定大小的虚拟页，这样虚拟页和物理页就有了一一对应的关系。
###虚拟存储器给我们带来了什么？
假如没有虚拟存储器系统，我们的每个程序就会变得很庞大，每个程序内存空间的大小不一致会导致每个程序的内存空间各式各样，杂乱无章。虚拟存储通过给每个进程提供独立的进程空间给我提供了如下的方便:

- 每个进程空间都有相同的基本格式(和代码的具体存放地址无关)
- 简化了共享，在没有虚拟存储管理的系统中，我们如果想调用printf函数，每个进程都需要将其加载到自己的进程空间中，如果有100个函数调用了printf函数在物理页上就会有100个共享库的拷贝。有了虚拟存储系统之后，每个进程的地址空间是独立的，我们可以将不用进程的虚拟页映射到相同的物理页，这样就大大的降低了存储器的开销。
- 简化了存储器的分配。系统调用再也不用关心底层的物理业的管理，每次系统调用后操作系统给他一个连续的虚拟页，然后等待使用的时候将其映射到实际的物理页上。

###我们调用fork和execve的时候发生了什么？
有了上述的概念之后，我们可以看看fork一个进程和之后调用execve函数时发生了什么？
当我们调用一次fork之后系统会给新进程创建一个存储空间，除了PID外其他所有的内容都是父进程的一份拷贝，之后写时拷贝机制就会在程序使用这段内存的时候创建新的页面。下面来看看fork一个进程后我们调用`execve("a.out", argv,evn)`后发生了什么？

- 删除已存在的用户区域。
- 映射私有区域。由于fork后子进程中仍然是一份父进程的拷贝，等调用execve后子进程有了自己的文本，数据，bss和栈区域，所以在调用execve之后将这部分映射到自己的地址空间中
- 映射共享区域。
- 设置程序计数器。




-END
[1]:../album/ch10/vm_memory.png "virtual memory managment"
