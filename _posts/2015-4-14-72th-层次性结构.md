---
date: 2015-4-14 21:53:12+00:00
layout: post
title: SICP 72th-层次性结构
thread: 21
categories: 读书笔记
tags: SICP
---
这一节会让你见识各种复杂的数据结构。序对确实是一个很强大的东西，它可以表示一切你所知道的数据结构。
###练习 2.24 求出表达式(list 1 (list 2 (list 3 4)))的盒式表达式和树形表达式
没什么复杂的东西，按照之前的练习画出来即可。
![1]
###练习 2.25 求出从以下表达式中取出数字7的car和cdr组合
	
	(1 3 (5 7) 9)
	((7))
	(1 (2 (3 (4 (5 (6 7))))))
这个题目就有点虐心了，尤其是最后一个句子的表示，一看上去绝对蒙了。不过还是有一点技巧的，从最里面向外看，第一个的cons表达式为(cons 1 (cons 3 (cons (cons 5 (cons 7 '())) (cons 9 '()))))，可以分解为:

	E = (cons 7 '())
	A = (cons 5 E)
	B = (cons A (cons 9 '()))
	C = (cons 3 B)
	D = (cons 1 C)
首先看下7是E的car，E是A的cdr，A是B的car，B是C的cdr，C是D的cdr，即7在(1 3 (5 7) 9)中的car cdr的组合是：

	(car (cdr (car (cdr (cdr (list 1 3 (list 5 7) 9)))))
其他的两个表达式也可以通过同样的方式表示出来，不过最后一个表示出来有点长。

### 练习 2.26 比较append cons list作用在序列表上的动作

</br>
### 练习 2.27 反转一个树，其中的子树叶必须反转
递归的反转一颗树的每一个子树，然后将第一个子树放到列表中的最后一个。
```
```

	(define (deep-reverse items)
		(cond ((null? items) items)
			((not (pair? items)) items)
			(else (append (deep-reverse (cdr items)) 
						(cons (deep-reverse (car items)) '())))))
测试code:
```
```

	
	(deep-reverse (list 1 2 3 4 5))
	(deep-reverse (list (list 1 2 3) (list 4 5 6)))
	(deep-reverse (list 1 2 (list 3 4) (list 5 6)))
	(deep-reverse (list 1 2 (list 3 4) (list 5 (list 6))))

###练习 2.28 返回一个树的所有叶子的集合
遍历所有的子树遇到不是序列的的item后返回，然后将这些单一的值添加到一个list中。
```
```

	(define (fringe items)
		(cond ((null? items) items)
			((not (pair? items)) (cons items '()))
			(else (append (fringe (car items)) (fringe (cdr items))))))
;测试 code
```
```

	(fringe (list 1 2 3 4 5))
	(fringe (list (list 1 2) (list 3 4)))
	(fringe (list (list (list 1 2) (list 3 4)) (list (list 1 2) (list 3 4))))
###练习 2.29 关于活动体的一些处理
(a)按照书中给的提示即可写出，不同的一点是cadr将会返回列表中的第二个元素。

(b)关于一个mobile的weight，即左右branch的weight之和。根据branch的定义可知每个branch的weight就是他的最右的那个叶子的值。
```
```

	(define (branch-weight branch)
		(if (not (pair? (branch-structure branch)))
			(branch-structure branch)
			(branch-weight (branch-structure branch))))

	(define (total-length mobile)
		(+ (branch-weight (left-branch mobile)) 
		   (branch-weight (right-branch mobile))))
(c)检测一个mobile是否是平衡的。首先我们根据力矩的定义给出力矩的实现:
```
```
	
	(define (branch-torque branch)
		(* (branch-length branch) (branch-weight branch)))
一个mobile必须满足一下的几点:

- 它的左右branch的力矩必须相等
- 它的左branch必须是平衡的
- 它的右branch必须是平衡的

根据上边的的条件可以得到:
```
```

	(define (branch-balance? branch)
		(if (pair? (branch-structure branch))
			(is-blance? (branch-structure branch))
			#t))
	(define (is-blance? moblie)
		(let ((left-b (left-branch moblie))
			 (right-b (right-branch moblie)))
			(and (eq? (branch-torque left-b) (branch-torque right-b))
			  (branch-balance? left-b)
			  (branch-balance? right-b))))
其中branch-balance?中直接返回#t要特别注意。如果这个branch的structure部分不是一个mobile的话直接返回#t，因为平衡与否是对一个有左右branch的mobile而言。如果一个mobile的一个branch的左右都是简单的数字这时候的平衡性交给(eq? (branch-torque left-b) (branch-torque right-b)判断即可。

测试code:
```
```

	(define left-b (make-branch 1 8))
	(define right-b (make-branch 2 4))
	(define mobile (make-moblie left-b right-b))
TEST for left-branch right-branch:
```
```

	(left-branch mobile)
	(right-branch mobile)
TEST for branch-length branch-structure:
```
```

	(branch-length left-b)
	(branch-structure left-b)
	(branch-length right-b)
	(branch-structure right-b)
TEST for branch-weight and total-weight:
```
```

	(define mobile-1 (make-moblie left-b (make-branch 2 mobile)))
	(branch-weight (left-branch mobile-1))
	(branch-weight (right-branch mobile-1))
	(total-length mobile-1)
TEST is-balance? for a balance mobile: 
```
```

	(branch-torque left-b)
	(branch-torque right-b)
	(is-blance? mobile)
	(is-blance? mobile-1)
TEST is-balance? for a unbalance mobile: 
```
```

	(define mobile-2 (make-moblie left-b (make-branch 3 mobile)))
	(is-blance? mobile-2)
###练习 2.30 两种形式的suqare-tree 
其实这个题和之前的scale-list差不多，唯一的不同就是前面scale-list中的每一个元素是一个单一的值，而这里可能是一个list。
```
```

    (define (square-tree tree)
		(cond ((null? tree) '())
			((not (pair? tree)) (square tree))
			(else (cons (square-tree (car tree)) (square-tree (cdr tree))))))

	(define (square-tree-1 tree)
		(map (lambda (sub-tree)
			(if (pair? sub-tree)
				(square-tree-1 sub-tree)
				(square sub-tree))) tree))
;test code
```
```

	(define y (list 1 (list 2 (list 3 4) 5 (list 6 7)))
	(square-tree y)
	(square-tree-1 y)
###练习 2.31 实现一个map形式的tree-map的过程其将过程proc作用于树的每一个元素上
主要还是参照map的实现，从左到右遍历树中的每一个元素，遇到叶子的时候将proc作用于叶子上并返回。
```
```

	(define (tree-map proc tree)
		(cond ((null? tree) '())
			((not (pair? tree)) (proc tree))
			(else (cons (tree-map proc (car tree)) (tree-map proc (cdr tree))))))

	(define (square-tree tree)
		(tree-map square tree))
测试code:
```
```

	(define y (list 1 (list 2 (list 3 4) 5 (list 6 7))))
	(square-tree y)

###练习 2.32 返回一个集合的所有子集
首先这个题要多观察，尤其是书中给出的例子，集合(1 2 3)的子集是((0) (2) (3) (2 3) (1) (1 2) (1 3 ) (1 2 3))。而集合(2 3)的子集是((0) (2) (3) (2 3)),从中可以看出，(1 2 3)的子集中相对于(2 3)的子集增加的集合是将1和(2 3)的每一个子集组成一个序对。所以在？？处应该填入的是将1和所有rest中的每个元素组合成序对的结果。
```
```

	(define (subset s)
		(if (null? s)
			(list '())
			(let ((rest (subset (cdr s))))
				(append rest (map (lambda (x) (cons (car s) x))rest)))))

这个看上去和换零钱的样子有点像。

-END
[1]:../album/SICP/ch2/box-tree.png  "box and tree of (1 (2 (3 4)))"
