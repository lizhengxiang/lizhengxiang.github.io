---
date: 2015-1-14 20:50:12+00:00
layout: post
title: Linker中的symbol检测规则
thread: 12
categories: 读书笔记
tags: CS-APP
---


##关于变量的作用域
之前在cnblog上写过一篇blog是从变量的存储位置解释变量的作用域的，今天看到linker是如何检查变量的作用域规则的时候给人眼前一亮的感觉。随录之。


##链接器中是怎样检测作用域的？
链接器是通过符号表来完成变量的符号检测的，每个模块m都有一个符号表，主要有以下三种符号:

- 由m定义能被其他模块有用的全局符号(非static的函数或者变量)
- 被其他模块定义并被m所引用的全局变量
- 只在模块m所定义或引用的本地模块

OK，有了以上的概念之后我们对C中的符号有了一定的概念了，现在来看看ld是如何去check上边的三种符号的，首先编译器输出每个全局符号给汇编器，附带了每个符号表的强弱学习([什么事符号表的强弱](http://en.wikipedia.org/wiki/Weak_symbol)),然后下面的规则来处理多处定义的符号:

- 不允许多个强符号
- 如果有一个强符号和多个若符号，那么选择强符号
- 如果有多个若符号，那么从其中任意的选择一个

针对第一条是很好理解的，如果两个文件中都有函数名相同的函数，那么GCC回报如下的错误。

>/tmp/ccpsWl5l.o: In function 'main':
>main.c:(.text+0x0): multiple definition of 'main'
>
>/tmp/cceELkgk.o:main.c:(.text+0x0): first defined here
>/tmp/cceELkgk.o: In function 'main':

我们再看下第二条，现在假设有如下的代码:

---------------ch7/foo3.c
```
```

	#include <stdio.h>
	void f(void);

	int __attribute__((weak))x = 15213;

	int main()
	{
   		printf("before f x = %d\n", x);
   		f();
   		printf("after x x = %d\n", x);
   		return 0;
	}

-------------ch7/bar3.c
```
```


	1 int x = 111111;
  	2 void f()
  	3 {
  	4    x = 15212;
  	5 }
首先我们在foo3文件中将x声明为了一个weak symbol，这样在程序中会使用bar3中的x而不是foo3中的x，请看如下的输出。
>before f x = 111111<br>
after x x = 15212

这一点在程序中是很难发现的，尤其是重复的符号定义有不用的类型的时候。如果一个模块中有一个weak的double x symbol,另一个模块中定义了一个strong的int x symbol，而此时你想用的是double类型的全局变量x，ooops~~~~。

所以说在声明一个变量的时候一定要做初始化，初始化了这个问题就可以在链接中解决，如果没有初始化而将这个问题带到运行期，那个这个问题就搞大了。

-END

	
