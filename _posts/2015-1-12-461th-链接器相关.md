---
date: 2015-1-13 20:50:12+00:00
layout: post
title: 从.c文件到生成可执行文件，编译器为我们做了哪些?
thread: 11
categories: 读书笔记
tags: CS-APP
---

##关于链接器
没有链接器的程序是无法想象的，所有的程序都在一个很大的源文件中，每个改动后又要重新编译整个文件,KISS,东西越是简单越是好用,使用的人也越是好理解。如果一个东西越是庞大出现错误的概率也是越大，不信你可以看看《人月神话》，这本身对于对软件项目的管理就像《Effective C++》至于C++，《C缺陷和陷阱》至于C。所有的软件都在向简单实用的方向发展(C++ 除外)，将一个很复杂的问题简单化，模块化。编译器的发展亦是如此，它使文件的分离编译成为可能，每有源代码发生变动后我们只需编译变动的部分，并将它重新链接起来，不用重新编译整个文件。

##可执行程序的生产过程
在C语言的世界里，生成可执行文件需要以下三个步骤,我想大概是在上大一上第一节C语言课程的时候知道的，当时的环境是TC2.0 蓝色的屏幕，一大堆的快捷键，对于当时还没怎么摸过电脑的我来说就是天外神物，那么的神奇。超级复杂的问题竟然可以一下子解出来。
![1]

但针对编译器的一个流程是怎么样的，一直是没有去尝试过。下面就跟着书上的例子去操作一遍吧。

先假设有以下两个文件

-----------------------------------ch7/main.c
```
```
 
  	1 #include <stdio.h>
	2
  	3 void swap();
  	4
  	5 int buf[2] = {1,2};
  	6
  	7 int main()
  	8 {
  	9    printf("before swap buf[0] = %d, buf[1] = %d\n", buf[0], buf[1]);
 	10    swap();
 	11    printf("after swap buf[0] = %d, buf[1] = %d\n", buf[0], buf[1]);
 	12    return 0;
 	13 }

------------------------------ch7/swap.c
```
```
  
	1 extern int buf[];
  	2
  	3 int *bufp0 = &buf[0];
  	4 int *bufp1;
  	5
 	6 void swap()
  	7 {
  	8    int temp;
  	9    bufp1 = &buf[1];
 	10    temp = *bufp0;
 	11    *bufp0 = *bufp1;
 	12    *bufp1 = temp;
 	13 }

下面看看Linux中的具体指令时什么吧！

![2]

注1.经过预处理后的文件你可以在[这里](https://github.com/lzh2nix/CS-APP/blob/master/ch7/main.i)查看

注2.编译器生成的汇编文件可以在[这里](https://github.com/lzh2nix/CS-APP/blob/master/ch7/main.s)查看


##关于Linker
关于最后的一步链接我本来是打算使用ld的但是死活不过，首先是`undefined reference to  printf`，之后是 `ld: warning: cannot find entry symbol _start; defaulting to 0000000008048094`,OK之后链接都OK了，等执行的时候提示`-bash: ./a.out: No such file or directory`.

总体来说整个是一个“no zuo no die”的过程，吐槽也是为了更好的工作 ^_^

-END



[1]:../album/ch7/program_process.png "program process"
[2]: ../album/ch7/process_compiler_linker.png "process_compiler_linker"
