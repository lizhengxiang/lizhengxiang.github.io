---
date: 2015-4-24 21:53:12+00:00
layout: post
title: SICP 76th-序列作为一种约定的界面
thread: 22
categories: 读书笔记
tags: SICP
---

这一节将程序的构造解释到了极致，怎样将一个大的函数按照不同的功能拆解成不同的函数，而后用此来构造功能不同的复杂函数。看到书中提高信号处理工程师就想到了大学的时光，想到了那本厚厚的奥本海姆的<信号与系统>，现在回过头去看那些知识的话，你就可以发现哪里都是叫你怎样分解一个系统的。
这一讲中的我们将会不断的使用到如下的模式:


	产生所有的序列集合------>filter 所需要的元素---->map 将proc作用到每个元素上

###练习 2.24 将**map**,**append**, **length**使用累积的形式表现出来
首先map的定义是这样的将proc作用到集合中的每一个元素上，并返回之后的集合
```
```

	(define (map p sequence)
		(accumulate (lambda (x y) (cons (p x) y)) '() sequence))
append 是将后面的序列中的每一个元素添加到前面的序列中,
假如:

	seq1 = (1 2 3 4) 
	seq2 = (5 6 7)
	append(seq1 seq2) = (1 2 3 4 5 6 7)
我们构造成一下的形式即可:
		
	(cons 1 (cons 2 （cons 3 (cons 4 seq2))))
对应的代码就是:
```
```

	(define (append seq1 seq2)
		(accumulate cons seq2 seq1))
length 就是求出序列中元素的个数，每次+1直到序对返回为空为止。
```
```

	(define (length sequence)
		(accumulate (lambda (x y) (+ 1 y)) 0 sequence))
### 练习2.34 多项式的求解
这个题的解的数学模型已经在书中说的很明白了。

		a0 + a1x + a2x^2 + a3x^3 + a4x^4
		= a0 + x(a1 + x(a2 + x(a3 + xa4)))
我们其实要做的就是将上述的数学模型翻译成机器能是别的程序，那个程序又不是这样的呢？将数学家们N年前发表的东西用现在的程序来解出来。针对这个题而说我们的输入参数是:x 和序列(a0 a1 a2 a3 a4)，套到累积的模板上就是:
```
```

	(define (horner-eval x coefficient-sequence)
		(accumulate (lambda (this-coeff higner-terms) 
						(+ this-coeff (* x higner-terms)))
					0
					coefficient-sequence))
### 练习2.35 count-leaves 的累积形式的定义
求出树上的leaves个数。如果该节点是一个单一的数那么返回剩余的节点的leaves数+1的结果，否则返回该节点的count-leaves + 剩余节点的count-leaves数。
```
```

	(define (count-leaves t)
		(accumulate (lambda (x y) 
						(if (not (pair? x))
							(+ 1 y)
							(+ (count-leaves x) y)))
					0
					t))
### 练习2.36； accumulate-n的表示
这里的第一个地方填入的应该是将s中每个序列的第1个元素取出的方法,第二个地方填入的就是将s中的每个序列中取出第一个元素后剩余的序列。
假如输入位((1 2 3) (4 5 6) (7 8 9) (10 11 12)),那么第一处函数返回的值应该是(1 4 7 10),第二处返回的应该是((2 3) (5 6) (8 9) (11 12)),依次循环直到s为空。
```
```

	(define (accumulate-n op init seqs)
		(if (null? (car seqs))
			'()
			(cons (accumulate op init (map (lambda (x) (car x)) seqs))
				(accumulate-n op init (map (lambda (x) (cdr x)) seqs)))))

### 练习2.37 矩阵的相关操作
做这个练习之前你需要清楚的知道矩阵的相关操作，相关知识可以参考大学的线性代数或者维基百科。其实这个题里的几个函数完全可以根据给出的公式求出来：

	matrix*-vector中 ti= sum(MijVj)
我们可以将这个公式在如下的数据上展开，假设：

	M =  ((1 2 3) (4 5 6) (7 8 9))
	V = (1 2 3)

	T0 = M00*V0 + M01*V1 + M02*v2 = (1 2 3)*(1 2 3)
	T1 = M10*V0 + M11*V1 + M12*v2 = (4 5 6)*(1 2 3)
	T2 = M20*V0 + M21*V1 + M22*v2 = (7 8 9)*(1 2 3)
代码:
```
```

	(define (matrix-*-vector m v)
		(map (lambda (x) (dot-product v x)) m))
矩阵转置。首先我们想想线性代数中的矩阵转置，如果矩阵M为((1 2 3) (4 5 6) (7 8 9))么他的转置就是:((1 4 7) (2 5 8) (3 6 9)),按照程序的理解就是将每个序列中的第N的元素取出的集合作为转置矩阵的第N个元素
```
```

	(define (transpose m)
        (accumulate-n cons '() m))
矩阵乘法。矩阵相乘的结果为，怎么样做矩阵乘法可以参考[维基百科](http://zh.wikipedia.org/wiki/%E7%9F%A9%E9%99%A3%E4%B9%98%E6%B3%95).
```
```
	
	(define (matrix-*-matrix m n)
		(let ((cols (transpose n)))
			(map (lambda (x) (matrix-*-vector cols x)) m)))

### 练习2.39 使用fold-right和fold-left实现reverse
```
```
	
	(define (reverse sequence)
		(fold-left (lambda (x y) (cons y x)) '() sequence))

	
	(define (reverse sequence)
		(fold-right (lambda (x y) (append y  (list x))) '() sequence))

### 练习2.40 产生序对(i, j)其中1 <= j < i <=n.
其实这一小节挺不好理解的，尤其是你要想到两层的lambda求解，在该题中，首先产生i=∈[1,n]然后对每个i生成一个j∈[1,i)的集合，然后对每个j返回(i,j)的集合。
```
```

	(define (unique-pairs n)
		(flatmap (lambda (x) 
					(map (lambda (p) (list x p)) 
						(enumerate-interval 1 (- x 1)))) (enumerate-interval 2 n)))

### 练习2.41 求出小于n的相异三元组,使得三元的和为n。
首先根据定义我们可以知道i,j,k的关系是0<= k <= j <= i <= n,取出所有的相异三元组的程序如下
```
```

	(define (all-ordered-triples n)
		(flatmap (lambda (i) 
					(flatmap (lambda (j) 
									(map (lambda (k) (list k j i)) 
									(enumerate-interval 0 j))) 
						(enumerate-interval 0 i)))
				(enumerate-interval 0 n)))
只后我们需要做的事情就是从上面的函数返回的序列中过滤出三元组的三元之和等于n的元素
```
```

	(define (sum-of-triples-equal-n n)
		(filter (lambda (seq) 
					(= (accumulate + 0 seq) n)) 
				(all-ordered-triples n)))

### 练习2.42 八皇后的表示
这个问题的话刚开始还不好理解，摆在我们面前的首要问题是怎样去表示一个八皇后的棋盘？首先想到的一个方法是（00000001）其中1表示该位置上有一个皇后0表示没有。但之后发现这个表示方法很明显没有网上的那个方法好。所以借鉴之。假如有以下的八皇后棋盘那么它的表示就是:
![1]

(1 5 2 6 3 7 4 8)

解这个题的时候你可以先不考虑saefe?函数，因为它只是一个filter,这里我们需要得到在每行上放一个棋子的N中方法。当k为0时我们应该返回一个空棋盘表示这时候没有皇后放置，但k=1时我们应该返回
8种结果分别为((1)(2)(3)(4)(5)(6)(7)(8))。所以empty-board 应该为一个空的list即为'(),
接下来就是adjoin-position函数，它将新的元素放到序表中的第一个元素的位置,比如上面例子中的8就是第一个元素的位置1就是最后一个元素的位置。
```
```

	(define (adjoin-position new-row k rest-of-queens)
		(cons new-row rest-of-queens))
剩余的最后一个问题就是safe?函数了，首先皇后不能在同一列上也就是说序列表中的元素不能重复.
```
```
	
	(define (not-in-line item seq)
		(cond ((null? seq) #t)
			((= item (car seq)) #f)
			(else (not-in-line item (cdr seq)))))
这个还是比较好理解的接下来就是不能在对角线上了。放第k的元素的时候我们只需要考虑他和钱k-1个元素的关系，而无须考虑他和之后元素的关系。上面的表示法的一个优点就是在这个地方。假如第k行上的元素的值是N，那么和第k的元素在对角线上的元素在第k-1行值是N-1和N+1，在第k-2行上的值是N-2和N+2，在第k-3行上的值是N-3和N+3，依次类推，如果到达边界后都没有值在对角线上那么该位置就是安全的了。
```
```

	(define (not-in-left-down item seq)
		(cond ((null? seq) #t)
	      ((= item (car seq)) #f)
	      (else (not-in-left-down (- item 1) (cdr seq)))))

	(define (not-in-right-down item seq)
		(cond ((null? seq) #t)
	      ((= item (car seq)) #f)
	      (else (not-in-right-down (+ item 1) (cdr seq)))))

最后的safe？函数如下，就是满足以上的三个条件。

	(define (safe? k positions)
	(let ((kth (car positions))
			(rest (cdr positions)))
		(and (not-in-line kth rest)
			  (not-in-left-down (- kth 1) rest)
			  (not-in-right-down (+ kth 1) rest))))

测试代码如下：
```
```

	;n:	1	2	3	4	5	6	7	8	9		10
	;all:	1	0	0	2	10	4	40	92	352	724	
	(= (length (queens 1 )) 1)
	(= (length (queens 2 )) 0)
	(= (length (queens 3 )) 0)
	(= (length (queens 4 )) 2)
	(= (length (queens 5 )) 10)
	(= (length (queens 6 )) 4)
	(= (length (queens 7 )) 40)
	(= (length (queens 8 )) 92)

-END
[1]:../album/SICP/ch2/eight-queens.png "eight-queens"
